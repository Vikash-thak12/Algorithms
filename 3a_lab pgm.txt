3a)
import java.util.ArrayList;
import java.util.Arrays;
import java.util.PriorityQueue;

class Edge implements Comparable<Edge> {
    int destination, weight;

    public Edge(int destination, int weight) {
        this.destination = destination;
        this.weight = weight;
    }

    @Override
    public int compareTo(Edge other) {
        return Integer.compare(this.weight, other.weight);
    }
}

public class PrimAlgorithm {

    public static void primMST(int[][] graph) {
        int vertices = graph.length;
        boolean[] visited = new boolean[vertices];
        int[] parent = new int[vertices];
        int[] key = new int[vertices];

        Arrays.fill(key, Integer.MAX_VALUE);
        key[0] = 0;
        parent[0] = -1;

        PriorityQueue<Edge> priorityQueue = new PriorityQueue<>();
        priorityQueue.add(new Edge(0, 0));

        while (!priorityQueue.isEmpty()) {
            int u = priorityQueue.poll().destination;
            visited[u] = true;

            for (int v = 0; v < vertices; v++) {
                if (graph[u][v] != 0 && !visited[v] && graph[u][v] < key[v]) {
                    key[v] = graph[u][v];
                    parent[v] = u;
                    priorityQueue.add(new Edge(v, key[v]));
                }
            }
        }

        printMST(parent, graph);
    }

    private static void printMST(int[] parent, int[][] graph) {
        System.out.println("Edge   Weight");
        for (int v = 1; v < graph.length; v++) {
            System.out.println(parent[v] + " - " + v + "    " + graph[v][parent[v]]);
        }
    }

    public static void main(String[] args) {
        int[][] graph = {
                {0, 2, 0, 6, 0},
                {2, 0, 3, 8, 5},
                {0, 3, 0, 0, 7},
                {6, 8, 0, 0, 9},
                {0, 5, 7, 9, 0}
        };

        primMST(graph);
    }
}
-------------------------------------------------------------
3b)
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;

class Edge implements Comparable<Edge> {
    int source, destination, weight;

    public Edge(int source, int destination, int weight) {
        this.source = source;
        this.destination = destination;
        this.weight = weight;
    }

    @Override
    public int compareTo(Edge other) {
        return Integer.compare(this.weight, other.weight);
    }
}

class UnionFind {
    private int[] parent, rank;

    public UnionFind(int size) {
        parent = new int[size];
        rank = new int[size];
        for (int i = 0; i < size; i++) {
            parent[i] = i;
            rank[i] = 0;
        }
    }

    public int find(int x) {
        if (parent[x] != x) {
            parent[x] = find(parent[x]);
        }
        return parent[x];
    }

    public void union(int x, int y) {
        int rootX = find(x);
        int rootY = find(y);

        if (rootX != rootY) {
            if (rank[rootX] < rank[rootY]) {
                parent[rootX] = rootY;
            } else if (rank[rootX] > rank[rootY]) {
                parent[rootY] = rootX;
            } else {
                parent[rootX] = rootY;
                rank[rootY]++;
            }
        }
    }
}

public class KruskalAlgorithm {

    public static void kruskalMST(ArrayList<Edge> edges, int vertices) {
        Collections.sort(edges);

        UnionFind unionFind = new UnionFind(vertices);

        System.out.println("Edge   Weight");

        for (Edge edge : edges) {
            int rootSource = unionFind.find(edge.source);
            int rootDest = unionFind.find(edge.destination);

            if (rootSource != rootDest) {
                System.out.println(edge.source + " - " + edge.destination + "    " + edge.weight);
                unionFind.union(rootSource, rootDest);
            }
        }
    }

    public static void main(String[] args) {
        int vertices = 5;
        ArrayList<Edge> edges = new ArrayList<>();

        edges.add(new Edge(0, 1, 2));
        edges.add(new Edge(0, 3, 6));
        edges.add(new Edge(1, 2, 3));
        edges.add(new Edge(1, 3, 8));
        edges.add(new Edge(1, 4, 5));
        edges.add(new Edge(2, 4, 7));
        edges.add(new Edge(3, 4, 9));

        kruskalMST(edges, vertices);
    }
}
-----------------------------------------------------
3c Java code to Implement All-Pairs Shortest Path Problem using Floydâ€™s algorithm.

public class FloydWarshall {
    private static final int INF = Integer.MAX_VALUE;

    public static void main(String[] args) {
        int[][] graph = {
                {0, 5, INF, 10},
                {INF, 0, 3, INF},
                {INF, INF, 0, 1},
                {INF, INF, INF, 0}
        };

        int[][] shortestPaths = floydWarshall(graph);
        printShortestPaths(shortestPaths);
    }

    public static int[][] floydWarshall(int[][] graph) {
        int V = graph.length;
        int[][] dist = new int[V][V];

        // Initialize dist matrix
        for (int i = 0; i < V; i++) {
            for (int j = 0; j < V; j++) {
                dist[i][j] = graph[i][j];
            }
        }

        // Apply Floyd-Warshall algorithm
        for (int k = 0; k < V; k++) {
            for (int i = 0; i < V; i++) {
                for (int j = 0; j < V; j++) {
                    if (dist[i][k] != INF && dist[k][j] != INF && dist[i][k] + dist[k][j] < dist[i][j]) {
                        dist[i][j] = dist[i][k] + dist[k][j];
                    }
                }
            }
        }

        return dist;
    }

    public static void printShortestPaths(int[][] shortestPaths) {
        int V = shortestPaths.length;
        System.out.println("Shortest paths between all pairs:");
        for (int i = 0; i < V; i++) {
            for (int j = 0; j < V; j++) {
                if (shortestPaths[i][j] == INF) {
                    System.out.print("INF\t");
                } else {
                    System.out.print(shortestPaths[i][j] + "\t");
                }
            }
            System.out.println();
        }
    }
}

------------------------------------------------------------------------------
3d.1 Write java code using Backtracking technique to solve n-Queens problem (n = 4, n =8)

public class NQueens {
    public static void main(String[] args) {
        solveNQueens(4);
        solveNQueens(8);
    }

    public static void solveNQueens(int n) {
        int[] board = new int[n];
        boolean foundSolution = placeQueens(board, 0);
        if (foundSolution) {
            System.out.println("Solution for n = " + n + ":");
            printBoard(board);
        } else {
            System.out.println("No solution found for n = " + n);
        }
    }

    public static boolean placeQueens(int[] board, int row) {
        int n = board.length;
        if (row == n) {
            return true; // All queens are successfully placed
        }

        for (int col = 0; col < n; col++) {
            if (isSafe(board, row, col)) {
                board[row] = col; // Place queen at (row, col)
                if (placeQueens(board, row + 1)) {
                    return true;
                }
                // If placing queen at (row, col) doesn't lead to a solution, backtrack
                board[row] = 0;
            }
        }
        return false; // No safe position found in this row
    }

    public static boolean isSafe(int[] board, int row, int col) {
        for (int i = 0; i < row; i++) {
            // Check if the queen can be attacked by a queen in previous rows
            if (board[i] == col || Math.abs(i - row) == Math.abs(board[i] - col)) {
                return false;
            }
        }
        return true;
    }

    public static void printBoard(int[] board) {
        int n = board.length;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (board[i] == j) {
                    System.out.print("Q ");
                } else {
                    System.out.print(". ");
                }
            }
            System.out.println();
        }
        System.out.println();
    }
}
---------------------------------------------------------------------------
3d.2 write a java program to Solve Sudoku puzzle using Backtracking technique.
public class SudokuSolver {
    private static final int SIZE = 9;
    private static final int EMPTY = 0;

    public static void main(String[] args) {
        int[][] sudokuGrid = {
            {5, 3, 0, 0, 7, 0, 0, 0, 0},
            {6, 0, 0, 1, 9, 5, 0, 0, 0},
            {0, 9, 8, 0, 0, 0, 0, 6, 0},
            {8, 0, 0, 0, 6, 0, 0, 0, 3},
            {4, 0, 0, 8, 0, 3, 0, 0, 1},
            {7, 0, 0, 0, 2, 0, 0, 0, 6},
            {0, 6, 0, 0, 0, 0, 2, 8, 0},
            {0, 0, 0, 4, 1, 9, 0, 0, 5},
            {0, 0, 0, 0, 8, 0, 0, 7, 9}
        };

        if (solveSudoku(sudokuGrid)) {
            System.out.println("Sudoku solved successfully:");
            printSudoku(sudokuGrid);
        } else {
            System.out.println("No solution exists for the given Sudoku puzzle.");
        }
    }

    public static boolean solveSudoku(int[][] grid) {
        int row, col;

        // Find an empty cell in the grid
        boolean isEmpty = true;
        for (row = 0; row < SIZE && isEmpty; row++) {
            for (col = 0; col < SIZE && isEmpty; col++) {
                if (grid[row][col] == EMPTY) {
                    isEmpty = false;
                }
            }
        }

        if (isEmpty) {
            return true; // Puzzle is solved
        }

        // Try placing numbers from 1 to 9 in the empty cell
        for (int num = 1; num <= SIZE; num++) {
            if (isValidMove(grid, row, col, num)) {
                grid[row][col] = num;

                // Recur to solve the rest of the puzzle
                if (solveSudoku(grid)) {
                    return true;
                }

                // If recursion doesn't lead to a solution, backtrack
                grid[row][col] = EMPTY;
            }
        }

        return false; // No solution found
    }

    public static boolean isValidMove(int[][] grid, int row, int col, int num) {
        // Check if num is not already in the current row, current column, and current 3x3 subgrid
        return !isNumInRow(grid, row, num) &&
               !isNumInColumn(grid, col, num) &&
               !isNumInSubgrid(grid, row - row % 3, col - col % 3, num);
    }

    public static boolean isNumInRow(int[][] grid, int row, int num) {
        for (int col = 0; col < SIZE; col++) {
            if (grid[row][col] == num) {
                return true;
            }
        }
        return false;
    }

    public static boolean isNumInColumn(int[][] grid, int col, int num) {
        for (int row = 0; row < SIZE; row++) {
            if (grid[row][col] == num) {
                return true;
            }
        }
        return false;
    }

    public static boolean isNumInSubgrid(int[][] grid, int startRow, int startCol, int num) {
        for (int row = 0; row < 3; row++) {
            for (int col = 0; col < 3; col++) {
                if (grid[row + startRow][col + startCol] == num) {
                    return true;
                }
            }
        }
        return false;
    }

    public static void printSudoku(int[][] grid) {
        for (int row = 0; row < SIZE; row++) {
            for (int col = 0; col < SIZE; col++) {
                System.out.print(grid[row][col] + " ");
            }
            System.out.println();
        }
    }
}
